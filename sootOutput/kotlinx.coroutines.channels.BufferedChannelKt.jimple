public final class kotlinx.coroutines.channels.BufferedChannelKt extends java.lang.Object
{
    public static final kotlinx.coroutines.internal.Symbol BUFFERED;
    private static final long BUFFER_END_RENDEZVOUS;
    private static final long BUFFER_END_UNLIMITED;
    private static final kotlinx.coroutines.internal.Symbol CHANNEL_CLOSED;
    private static final kotlinx.coroutines.internal.Symbol CLOSE_HANDLER_CLOSED;
    private static final kotlinx.coroutines.internal.Symbol CLOSE_HANDLER_INVOKED;
    private static final int CLOSE_STATUS_ACTIVE;
    private static final int CLOSE_STATUS_CANCELLATION_STARTED;
    private static final int CLOSE_STATUS_CANCELLED;
    private static final int CLOSE_STATUS_CLOSED;
    private static final kotlinx.coroutines.internal.Symbol DONE_RCV;
    private static final long EB_COMPLETED_COUNTER_MASK;
    private static final long EB_COMPLETED_PAUSE_EXPAND_BUFFERS_BIT;
    private static final int EXPAND_BUFFER_COMPLETION_WAIT_ITERATIONS;
    private static final kotlinx.coroutines.internal.Symbol FAILED;
    private static final kotlinx.coroutines.internal.Symbol INTERRUPTED_RCV;
    private static final kotlinx.coroutines.internal.Symbol INTERRUPTED_SEND;
    private static final kotlinx.coroutines.internal.Symbol IN_BUFFER;
    private static final kotlinx.coroutines.internal.Symbol NO_CLOSE_CAUSE;
    private static final kotlinx.coroutines.internal.Symbol NO_RECEIVE_RESULT;
    private static final kotlinx.coroutines.channels.ChannelSegment NULL_SEGMENT;
    private static final kotlinx.coroutines.internal.Symbol POISONED;
    private static final int RESULT_BUFFERED;
    private static final int RESULT_CLOSED;
    private static final int RESULT_FAILED;
    private static final int RESULT_RENDEZVOUS;
    private static final int RESULT_SUSPEND;
    private static final int RESULT_SUSPEND_NO_WAITER;
    private static final kotlinx.coroutines.internal.Symbol RESUMING_BY_EB;
    private static final kotlinx.coroutines.internal.Symbol RESUMING_BY_RCV;
    public static final int SEGMENT_SIZE;
    private static final int SENDERS_CLOSE_STATUS_SHIFT;
    private static final long SENDERS_COUNTER_MASK;
    private static final kotlinx.coroutines.internal.Symbol SUSPEND;
    private static final kotlinx.coroutines.internal.Symbol SUSPEND_NO_WAITER;

    static void <clinit>()
    {
        int $i0;
        kotlinx.coroutines.internal.Symbol $r1;
        kotlinx.coroutines.channels.ChannelSegment $r0;

        <kotlinx.coroutines.channels.BufferedChannelKt: long SENDERS_COUNTER_MASK> = 1152921504606846975L;

        <kotlinx.coroutines.channels.BufferedChannelKt: int SENDERS_CLOSE_STATUS_SHIFT> = 60;

        <kotlinx.coroutines.channels.BufferedChannelKt: int RESULT_SUSPEND_NO_WAITER> = 3;

        <kotlinx.coroutines.channels.BufferedChannelKt: int RESULT_SUSPEND> = 2;

        <kotlinx.coroutines.channels.BufferedChannelKt: int RESULT_RENDEZVOUS> = 0;

        <kotlinx.coroutines.channels.BufferedChannelKt: int RESULT_FAILED> = 5;

        <kotlinx.coroutines.channels.BufferedChannelKt: int RESULT_CLOSED> = 4;

        <kotlinx.coroutines.channels.BufferedChannelKt: int RESULT_BUFFERED> = 1;

        <kotlinx.coroutines.channels.BufferedChannelKt: long EB_COMPLETED_PAUSE_EXPAND_BUFFERS_BIT> = 4611686018427387904L;

        <kotlinx.coroutines.channels.BufferedChannelKt: long EB_COMPLETED_COUNTER_MASK> = 4611686018427387903L;

        <kotlinx.coroutines.channels.BufferedChannelKt: int CLOSE_STATUS_CLOSED> = 2;

        <kotlinx.coroutines.channels.BufferedChannelKt: int CLOSE_STATUS_CANCELLED> = 3;

        <kotlinx.coroutines.channels.BufferedChannelKt: int CLOSE_STATUS_CANCELLATION_STARTED> = 1;

        <kotlinx.coroutines.channels.BufferedChannelKt: int CLOSE_STATUS_ACTIVE> = 0;

        <kotlinx.coroutines.channels.BufferedChannelKt: long BUFFER_END_UNLIMITED> = 9223372036854775807L;

        <kotlinx.coroutines.channels.BufferedChannelKt: long BUFFER_END_RENDEZVOUS> = 0L;

        $r0 = new kotlinx.coroutines.channels.ChannelSegment;

        specialinvoke $r0.<kotlinx.coroutines.channels.ChannelSegment: void <init>(long,kotlinx.coroutines.channels.ChannelSegment,kotlinx.coroutines.channels.BufferedChannel,int)>(-1L, null, null, 0);

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.channels.ChannelSegment NULL_SEGMENT> = $r0;

        $i0 = staticinvoke <kotlinx.coroutines.internal.SystemPropsKt: int systemProp$default(java.lang.String,int,int,int,int,java.lang.Object)>("kotlinx.coroutines.bufferedChannel.segmentSize", 32, 0, 0, 12, null);

        <kotlinx.coroutines.channels.BufferedChannelKt: int SEGMENT_SIZE> = $i0;

        $i0 = staticinvoke <kotlinx.coroutines.internal.SystemPropsKt: int systemProp$default(java.lang.String,int,int,int,int,java.lang.Object)>("kotlinx.coroutines.bufferedChannel.expandBufferCompletionWaitIterations", 10000, 0, 0, 12, null);

        <kotlinx.coroutines.channels.BufferedChannelKt: int EXPAND_BUFFER_COMPLETION_WAIT_ITERATIONS> = $i0;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("BUFFERED");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol BUFFERED> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("SHOULD_BUFFER");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol IN_BUFFER> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("S_RESUMING_BY_RCV");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol RESUMING_BY_RCV> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("RESUMING_BY_EB");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol RESUMING_BY_EB> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("POISONED");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol POISONED> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("DONE_RCV");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol DONE_RCV> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("INTERRUPTED_SEND");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol INTERRUPTED_SEND> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("INTERRUPTED_RCV");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol INTERRUPTED_RCV> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("CHANNEL_CLOSED");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol CHANNEL_CLOSED> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("SUSPEND");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol SUSPEND> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("SUSPEND_NO_WAITER");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol SUSPEND_NO_WAITER> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("FAILED");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol FAILED> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("NO_RECEIVE_RESULT");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol NO_RECEIVE_RESULT> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("CLOSE_HANDLER_CLOSED");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol CLOSE_HANDLER_CLOSED> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("CLOSE_HANDLER_INVOKED");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol CLOSE_HANDLER_INVOKED> = $r1;

        $r1 = new kotlinx.coroutines.internal.Symbol;

        specialinvoke $r1.<kotlinx.coroutines.internal.Symbol: void <init>(java.lang.String)>("NO_CLOSE_CAUSE");

        <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol NO_CLOSE_CAUSE> = $r1;

        return;
    }

    public static final long access$constructEBCompletedAndPauseFlag(long, boolean)
    {
        long $l0;
        boolean $z0;

        $l0 := @parameter0: long;

        $z0 := @parameter1: boolean;

        $l0 = staticinvoke <kotlinx.coroutines.channels.BufferedChannelKt: long constructEBCompletedAndPauseFlag(long,boolean)>($l0, $z0);

        return $l0;
    }

    public static final long access$constructSendersAndCloseStatus(long, int)
    {
        int $i1;
        long $l0;

        $l0 := @parameter0: long;

        $i1 := @parameter1: int;

        $l0 = staticinvoke <kotlinx.coroutines.channels.BufferedChannelKt: long constructSendersAndCloseStatus(long,int)>($l0, $i1);

        return $l0;
    }

    public static final kotlinx.coroutines.channels.ChannelSegment access$createSegment(long, kotlinx.coroutines.channels.ChannelSegment)
    {
        kotlinx.coroutines.channels.ChannelSegment $r0;
        long $l0;

        $l0 := @parameter0: long;

        $r0 := @parameter1: kotlinx.coroutines.channels.ChannelSegment;

        $r0 = staticinvoke <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.channels.ChannelSegment createSegment(long,kotlinx.coroutines.channels.ChannelSegment)>($l0, $r0);

        return $r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getCLOSE_HANDLER_CLOSED$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol CLOSE_HANDLER_CLOSED>;

        return r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getCLOSE_HANDLER_INVOKED$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol CLOSE_HANDLER_INVOKED>;

        return r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getDONE_RCV$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol DONE_RCV>;

        return r0;
    }

    public static final int access$getEXPAND_BUFFER_COMPLETION_WAIT_ITERATIONS$p()
    {
        int i0;

        i0 = <kotlinx.coroutines.channels.BufferedChannelKt: int EXPAND_BUFFER_COMPLETION_WAIT_ITERATIONS>;

        return i0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getFAILED$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol FAILED>;

        return r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getINTERRUPTED_RCV$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol INTERRUPTED_RCV>;

        return r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getINTERRUPTED_SEND$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol INTERRUPTED_SEND>;

        return r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getIN_BUFFER$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol IN_BUFFER>;

        return r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getNO_CLOSE_CAUSE$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol NO_CLOSE_CAUSE>;

        return r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getNO_RECEIVE_RESULT$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol NO_RECEIVE_RESULT>;

        return r0;
    }

    public static final kotlinx.coroutines.channels.ChannelSegment access$getNULL_SEGMENT$p()
    {
        kotlinx.coroutines.channels.ChannelSegment r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.channels.ChannelSegment NULL_SEGMENT>;

        return r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getPOISONED$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol POISONED>;

        return r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getRESUMING_BY_EB$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol RESUMING_BY_EB>;

        return r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getRESUMING_BY_RCV$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol RESUMING_BY_RCV>;

        return r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getSUSPEND$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol SUSPEND>;

        return r0;
    }

    public static final kotlinx.coroutines.internal.Symbol access$getSUSPEND_NO_WAITER$p()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol SUSPEND_NO_WAITER>;

        return r0;
    }

    public static final long access$initialBufferEnd(int)
    {
        int $i0;
        long $l1;

        $i0 := @parameter0: int;

        $l1 = staticinvoke <kotlinx.coroutines.channels.BufferedChannelKt: long initialBufferEnd(int)>($i0);

        return $l1;
    }

    public static final boolean access$tryResume0(kotlinx.coroutines.CancellableContinuation, java.lang.Object, kotlin.jvm.functions.Function1)
    {
        kotlinx.coroutines.CancellableContinuation $r0;
        java.lang.Object $r1;
        kotlin.jvm.functions.Function1 $r2;
        boolean $z0;

        $r0 := @parameter0: kotlinx.coroutines.CancellableContinuation;

        $r1 := @parameter1: java.lang.Object;

        $r2 := @parameter2: kotlin.jvm.functions.Function1;

        $z0 = staticinvoke <kotlinx.coroutines.channels.BufferedChannelKt: boolean tryResume0(kotlinx.coroutines.CancellableContinuation,java.lang.Object,kotlin.jvm.functions.Function1)>($r0, $r1, $r2);

        return $z0;
    }

    private static final long constructEBCompletedAndPauseFlag(long, boolean)
    {
        long $l0, $l1;
        boolean $z0;

        $l0 := @parameter0: long;

        $z0 := @parameter1: boolean;

        if $z0 == 0 goto label1;

        $l1 = 4611686018427387904L;

        goto label2;

     label1:
        $l1 = 0L;

     label2:
        $l0 = $l1 + $l0;

        return $l0;
    }

    private static final long constructSendersAndCloseStatus(long, int)
    {
        int $i1;
        long $l0, $l2;

        $l0 := @parameter0: long;

        $i1 := @parameter1: int;

        $l2 = (long) $i1;

        $l2 = $l2 << 60;

        $l0 = $l2 + $l0;

        return $l0;
    }

    private static final kotlinx.coroutines.channels.ChannelSegment createSegment(long, kotlinx.coroutines.channels.ChannelSegment)
    {
        kotlinx.coroutines.channels.ChannelSegment $r0, $r1;
        long $l0;
        kotlinx.coroutines.channels.BufferedChannel $r2;

        $l0 := @parameter0: long;

        $r0 := @parameter1: kotlinx.coroutines.channels.ChannelSegment;

        $r1 = new kotlinx.coroutines.channels.ChannelSegment;

        $r2 = virtualinvoke $r0.<kotlinx.coroutines.channels.ChannelSegment: kotlinx.coroutines.channels.BufferedChannel getChannel()>();

        specialinvoke $r1.<kotlinx.coroutines.channels.ChannelSegment: void <init>(long,kotlinx.coroutines.channels.ChannelSegment,kotlinx.coroutines.channels.BufferedChannel,int)>($l0, $r0, $r2, 0);

        return $r1;
    }

    public static final kotlin.reflect.KFunction createSegmentFunction()
    {
        kotlinx.coroutines.channels.BufferedChannelKt$createSegmentFunction$1 $r0;
        kotlin.reflect.KFunction $r1;

        $r0 = <kotlinx.coroutines.channels.BufferedChannelKt$createSegmentFunction$1: kotlinx.coroutines.channels.BufferedChannelKt$createSegmentFunction$1 INSTANCE>;

        $r1 = (kotlin.reflect.KFunction) $r0;

        return $r1;
    }

    public static final kotlinx.coroutines.internal.Symbol getCHANNEL_CLOSED()
    {
        kotlinx.coroutines.internal.Symbol r0;

        r0 = <kotlinx.coroutines.channels.BufferedChannelKt: kotlinx.coroutines.internal.Symbol CHANNEL_CLOSED>;

        return r0;
    }

    private static final long getEbCompletedCounter(long)
    {
        long $l0;

        $l0 := @parameter0: long;

        $l0 = 4611686018427387903L & $l0;

        return $l0;
    }

    private static final boolean getEbPauseExpandBuffers(long)
    {
        long $l0;
        byte $b1;

        $l0 := @parameter0: long;

        $l0 = 4611686018427387904L & $l0;

        $b1 = $l0 cmp 0L;

        if $b1 == 0 goto label1;

        return 1;

     label1:
        return 0;
    }

    private static final int getSendersCloseStatus(long)
    {
        int $i1;
        long $l0;

        $l0 := @parameter0: long;

        $l0 = $l0 >> 60;

        $i1 = (int) $l0;

        return $i1;
    }

    private static final long getSendersCounter(long)
    {
        long $l0;

        $l0 := @parameter0: long;

        $l0 = 1152921504606846975L & $l0;

        return $l0;
    }

    private static final long initialBufferEnd(int)
    {
        int $i0;
        long $l1;

        $i0 := @parameter0: int;

        lookupswitch($i0)
        {
            case 0: goto label3;
            case 2147483647: goto label2;
            default: goto label1;
        };

     label1:
        $l1 = (long) $i0;

        return $l1;

     label2:
        return 9223372036854775807L;

     label3:
        return 0L;
    }

    private static final boolean tryResume0(kotlinx.coroutines.CancellableContinuation, java.lang.Object, kotlin.jvm.functions.Function1)
    {
        kotlinx.coroutines.CancellableContinuation $r0;
        java.lang.Object $r1;
        kotlin.jvm.functions.Function1 $r2;
        boolean $z0;

        $r0 := @parameter0: kotlinx.coroutines.CancellableContinuation;

        $r1 := @parameter1: java.lang.Object;

        $r2 := @parameter2: kotlin.jvm.functions.Function1;

        $r1 = interfaceinvoke $r0.<kotlinx.coroutines.CancellableContinuation: java.lang.Object tryResume(java.lang.Object,java.lang.Object,kotlin.jvm.functions.Function1)>($r1, null, $r2);

        if $r1 == null goto label1;

        interfaceinvoke $r0.<kotlinx.coroutines.CancellableContinuation: void completeResume(java.lang.Object)>($r1);

        $z0 = 1;

        goto label2;

     label1:
        $z0 = 0;

     label2:
        return $z0;
    }

    static boolean tryResume0$default(kotlinx.coroutines.CancellableContinuation, java.lang.Object, kotlin.jvm.functions.Function1, int, java.lang.Object)
    {
        kotlinx.coroutines.CancellableContinuation $r2;
        int $i0;
        java.lang.Object $r0, $r1;
        kotlin.jvm.functions.Function1 $r3;
        boolean $z0;

        $r2 := @parameter0: kotlinx.coroutines.CancellableContinuation;

        $r0 := @parameter1: java.lang.Object;

        $r3 := @parameter2: kotlin.jvm.functions.Function1;

        $i0 := @parameter3: int;

        $r1 := @parameter4: java.lang.Object;

        $i0 = $i0 & 2;

        if $i0 == 0 goto label1;

        $r3 = null;

     label1:
        $z0 = staticinvoke <kotlinx.coroutines.channels.BufferedChannelKt: boolean tryResume0(kotlinx.coroutines.CancellableContinuation,java.lang.Object,kotlin.jvm.functions.Function1)>($r2, $r0, $r3);

        return $z0;
    }
}
