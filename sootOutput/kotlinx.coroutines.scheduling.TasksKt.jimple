public final class kotlinx.coroutines.scheduling.TasksKt extends java.lang.Object
{
    public static final kotlinx.coroutines.scheduling.TaskContext BlockingContext;
    public static final int CORE_POOL_SIZE;
    public static final java.lang.String DEFAULT_SCHEDULER_NAME;
    public static final long IDLE_WORKER_KEEP_ALIVE_NS;
    public static final int MAX_POOL_SIZE;
    public static final kotlinx.coroutines.scheduling.TaskContext NonBlockingContext;
    public static final int TASK_NON_BLOCKING;
    public static final int TASK_PROBABLY_BLOCKING;
    public static final long WORK_STEALING_TIME_RESOLUTION_NS;
    public static kotlinx.coroutines.scheduling.SchedulerTimeSource schedulerTimeSource;

    static void <clinit>()
    {
        long $l0;
        kotlinx.coroutines.scheduling.NanoTimeSource $r2;
        kotlinx.coroutines.scheduling.TaskContext $r5;
        java.util.concurrent.TimeUnit $r1;
        kotlinx.coroutines.scheduling.SchedulerTimeSource $r3;
        int $i1;
        kotlinx.coroutines.scheduling.TaskContextImpl $r4;
        java.lang.String $r0;

        <kotlinx.coroutines.scheduling.TasksKt: int TASK_PROBABLY_BLOCKING> = 1;

        <kotlinx.coroutines.scheduling.TasksKt: int TASK_NON_BLOCKING> = 0;

        $r0 = staticinvoke <kotlinx.coroutines.internal.SystemPropsKt: java.lang.String systemProp(java.lang.String,java.lang.String)>("kotlinx.coroutines.scheduler.default.name", "DefaultDispatcher");

        <kotlinx.coroutines.scheduling.TasksKt: java.lang.String DEFAULT_SCHEDULER_NAME> = $r0;

        $l0 = staticinvoke <kotlinx.coroutines.internal.SystemPropsKt: long systemProp$default(java.lang.String,long,long,long,int,java.lang.Object)>("kotlinx.coroutines.scheduler.resolution.ns", 100000L, 0L, 0L, 12, null);

        <kotlinx.coroutines.scheduling.TasksKt: long WORK_STEALING_TIME_RESOLUTION_NS> = $l0;

        $i1 = staticinvoke <kotlinx.coroutines.internal.SystemPropsKt: int getAVAILABLE_PROCESSORS()>();

        $i1 = staticinvoke <kotlin.ranges.RangesKt: int coerceAtLeast(int,int)>($i1, 2);

        $i1 = staticinvoke <kotlinx.coroutines.internal.SystemPropsKt: int systemProp$default(java.lang.String,int,int,int,int,java.lang.Object)>("kotlinx.coroutines.scheduler.core.pool.size", $i1, 1, 0, 8, null);

        <kotlinx.coroutines.scheduling.TasksKt: int CORE_POOL_SIZE> = $i1;

        $i1 = staticinvoke <kotlinx.coroutines.internal.SystemPropsKt: int systemProp$default(java.lang.String,int,int,int,int,java.lang.Object)>("kotlinx.coroutines.scheduler.max.pool.size", 2097150, 0, 2097150, 4, null);

        <kotlinx.coroutines.scheduling.TasksKt: int MAX_POOL_SIZE> = $i1;

        $r1 = <java.util.concurrent.TimeUnit: java.util.concurrent.TimeUnit SECONDS>;

        $l0 = staticinvoke <kotlinx.coroutines.internal.SystemPropsKt: long systemProp$default(java.lang.String,long,long,long,int,java.lang.Object)>("kotlinx.coroutines.scheduler.keep.alive.sec", 60L, 0L, 0L, 12, null);

        $l0 = virtualinvoke $r1.<java.util.concurrent.TimeUnit: long toNanos(long)>($l0);

        <kotlinx.coroutines.scheduling.TasksKt: long IDLE_WORKER_KEEP_ALIVE_NS> = $l0;

        $r2 = <kotlinx.coroutines.scheduling.NanoTimeSource: kotlinx.coroutines.scheduling.NanoTimeSource INSTANCE>;

        $r3 = (kotlinx.coroutines.scheduling.SchedulerTimeSource) $r2;

        <kotlinx.coroutines.scheduling.TasksKt: kotlinx.coroutines.scheduling.SchedulerTimeSource schedulerTimeSource> = $r3;

        $r4 = new kotlinx.coroutines.scheduling.TaskContextImpl;

        specialinvoke $r4.<kotlinx.coroutines.scheduling.TaskContextImpl: void <init>(int)>(0);

        $r5 = (kotlinx.coroutines.scheduling.TaskContext) $r4;

        <kotlinx.coroutines.scheduling.TasksKt: kotlinx.coroutines.scheduling.TaskContext NonBlockingContext> = $r5;

        $r4 = new kotlinx.coroutines.scheduling.TaskContextImpl;

        specialinvoke $r4.<kotlinx.coroutines.scheduling.TaskContextImpl: void <init>(int)>(1);

        $r5 = (kotlinx.coroutines.scheduling.TaskContext) $r4;

        <kotlinx.coroutines.scheduling.TasksKt: kotlinx.coroutines.scheduling.TaskContext BlockingContext> = $r5;

        return;
    }

    public static final boolean isBlocking(kotlinx.coroutines.scheduling.Task)
    {
        int $i0;
        kotlinx.coroutines.scheduling.TaskContext $r1;
        kotlinx.coroutines.scheduling.Task $r0;

        $r0 := @parameter0: kotlinx.coroutines.scheduling.Task;

        $r1 = $r0.<kotlinx.coroutines.scheduling.Task: kotlinx.coroutines.scheduling.TaskContext taskContext>;

        $i0 = interfaceinvoke $r1.<kotlinx.coroutines.scheduling.TaskContext: int getTaskMode()>();

        if $i0 != 1 goto label1;

        return 1;

     label1:
        return 0;
    }
}
